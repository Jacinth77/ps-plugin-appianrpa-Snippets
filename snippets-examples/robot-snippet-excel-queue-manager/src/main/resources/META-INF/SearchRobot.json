{"id":"SearchRobot","robotType":"ROBOT","mainClass":"com.appian.rpa.snippets.examples.queuemanager.SearchRobot","actions":["start","assignQueue","openBrowser","searchTerm","updateQueueItem","closeQueue","end"],"conditionalActions":["startUp","hasMoreItems"],"fieldLinks":[],"actionDetails":[{"id":"start","implementation":"/**\n\t * Start action where to initialize the global variables\n\t */\npublic void start() {\n}"},{"id":"assignQueue","implementation":"/**\n\t * Assigns the queue using the given Excel file or usign the preselected queue.\n\t */\npublic void assignQueue() {\n    try {\n        excelQueueManager.assignQueue();\n        server.setNumberOfItems(excelQueueManager.getCurrentQueue().pendingItems());\n    } catch (Exception e) {\n        throw new  JidokaFatalException(\"Error assigning the queue\", e);\n    }\n}"},{"id":"openBrowser","implementation":"/**\n\t * Opens the browser\n\t */\npublic void openBrowser() {\n    try {\n        browserManager.openBrowser();\n    } catch (Exception e) {\n        throw new  JidokaFatalException(\"Error opening the browser\", e);\n    }\n}"},{"id":"searchTerm","implementation":"/**\n\t * Search for the current {@linkplain SearchModel} object search term.\n\t */\npublic void searchTerm() {\n    try {\n        String url = MessageFormat.format(SEARCH_URL, URLEncoder.encode(currentSearch.getSearchTerm(), \"UTF-8\"));\n        browserManager.navigateTo(url);\n        // It is used an array instead of a simple object to avoid the error:\n        // Local variable searchResults defined in an enclosing scope must be final or\n        // effectively final\n        WebElement[] searchResults = new WebElement[1];\n        client.getWaitFor(this).wait(10, \"Waiting for search results\", false, false, ()->{\n    try {\n        searchResults[0] = selectorsManager.getElement(\"resultsPage.numberOfResults.id\");\n        return searchResults[0] != null;\n    } catch (Exception e) {\n        return false;\n    }\n});\n        if (searchResults.length == 0) {\n            // Results not found.\n            throw new  JidokaItemException(String.format(\"Search term %s not found: \", currentSearch.getSearchTerm()));\n        }\n        // Extracts the search results number\n        Pattern p = Pattern.compile(\".*?(\\\\d.*?)\\\\s.*\");\n        Matcher m = p.matcher(searchResults[0].getText());\n        if (m.find()) {\n            currentSearch.setNumberOfResults(m.group(1).replace(\",\", \"\"));\n        } else {\n            throw new  JidokaItemException(\"NUMBER OF RESULTS not found\");\n        }\n        WebElement timeRequired = selectorsManager.getElement(\"resultsPage.timeRequired.css\");\n        if (timeRequired == null) {\n            // Time required not found.\n            throw new  JidokaItemException(String.format(\"Time required %s not found for search term: \", currentSearch.getSearchTerm()));\n        }\n        Pattern p2 = Pattern.compile(\"\\\\((\\\\d.*?)\\\\s.*\");\n        Matcher m2 = p2.matcher(timeRequired.getText());\n        if (m2.find()) {\n            currentSearch.setTimeRequired(m2.group(1));\n        } else {\n            throw new  JidokaItemException(\"TIME_REQUIRED not found\");\n        }\n    } catch (UnsupportedEncodingException | JidokaUnsatisfiedConditionException e) {\n        throw new  JidokaItemException(\"Error searching for the term '\" + currentSearch.getSearchTerm() + \"'\");\n    }\n}"},{"id":"updateQueueItem","implementation":"/**\n\t * Updates the current queue item functional data and sets it to OK.\n\t */\npublic void updateQueueItem() {\n    try {\n        server.setCurrentItemResultToOK();\n        excelQueueManager.saveItem(currentSearch);\n    } catch (Exception e) {\n        throw new  JidokaItemException(\"Error updating the item '\" + currentSearch.getSearchTerm() + \"'\");\n    }\n}"},{"id":"closeQueue","implementation":"/**\n\t * Closes the queue and sets the results target to an Excel file\n\t */\npublic void closeQueue() {\n    try {\n        // First we reserve the queue (other robots can't reserve the queue at the same\n        excelQueueManager.closeQueue(EQueueResultTarget.EXCEL);\n    } catch (Exception e) {\n        throw new  JidokaFatalException(\"Error closing the current queue\", e);\n    }\n}"},{"id":"end","implementation":"/**\n\t * Action 'End'.\n\t */\npublic void end() {\n}"}],"conditionalActionDetails":[{"id":"startUp","implementation":"@Override\npublic boolean startUp() throws Exception {\n    // Inits libraries and modules\n    server = JidokaFactory.getServer();\n    client = IClient.getInstance(this);\n    excelQueueManager = new  ExcelQueueManager(this, new  SearchMapper());\n    browserManager = new  BrowserManager(this, EBrowsers.CHROME);\n    selectorsManager = browserManager.getSelectorsManager();\n    return IRobot.super.startUp();\n}"},{"id":"hasMoreItems","implementation":"/**\n\t * Checks if there are more items to process on the queue\n\t * \n\t * @return 'yes' if there are more items to process. Otherwise, returns 'no'.\n\t */\npublic String hasMoreItems() {\n    try {\n        // retrieve the next item in the queue\n        currentSearch = excelQueueManager.getNextItem();\n        if (currentSearch != null) {\n            // set the stats for the current item\n            currentItemIndex++;\n            server.setCurrentItem(currentItemIndex, currentSearch.getSearchTerm());\n            return \"yes\";\n        }\n        return \"no\";\n    } catch (Exception e) {\n        throw new  JidokaFatalException(\"Error getting the next item\", e);\n    }\n}"}],"sdkMethods":[]}